// 解题思路：
//   1. 从数组的头部开始遍历，如果遇到0，则把该元素后面的元素都往前面移动
//   2. 但是有可能存在多个连续的0的情况，因此遇到0之后又要去判断该0连续几次
//   3. 因此当遇到0之后，又要开始新的遍历，从当前的后一个元素开始问，是不是0，
//   4. 如果是0,则计数器+1，否则直接中断
//   5. 假如0只有1个，则当前位置的后面所有元素都要往前移动1格
//   6. 假如0有3个，则当前位置的后面第三个元素开始，都要往前移动3格，以此类推
//   7. 往前移动了 几格，后面必然会多出几个空位，这些空位都要 存储0

// 边界问题
// 假如最后一个是 0，由于本来就是要放后面的，因此此情况 最后一个元素可以被忽略
// 假如最后一个元素不是0，由于后面的操作（移动数组元素），
// 而移动的长度至少是 1（那就说明最后一个元素会被往前挪），因此此情况 最后一个元素可以被忽略
// 如果数组没被移动过，则说明数组的0已经全部在末尾，那此时也不要考虑最后一个元素了
// 综上 因此数组最后一个元素不需要考虑

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  const length = nums.length;

  for (let i = 0; i < length - 1; i++) {
    if (nums[i] !== 0) {
      continue;
    }

    let count = 1; // 统计当前 0 出现过多少次

    // 统计连续0的个数
    for (let j = i + 1; j < length - 1; j++) {
      if (nums[j] !== 0) {
        break;
      }

      count++;
    }

    // 移动数组元素，后面的往前面挪，挪动的步伐为连续0的个数
    for (let j = i; j < length - 1; j++) {
      // 判断是否越界 越界了则表明数组已经全部移动完成
      nums[j] = nums[j + count];
    }

    // 讲后面腾出的空间塞入 0
    while (count) {
      nums[length - count] = 0;
      count--;
    }
  }
};
