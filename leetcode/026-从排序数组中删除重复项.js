// 解题思路：
//   1. 从头部开始遍历该数组，
//   2. 判断当前元素是否为重复元素，判断标准为 当前元素 和 下一个元素相比较
//   3. 如果它 和 下一个元素不相等，则该元素不是重复元素，则进行下一轮循环
//   4. 如果它 和 下一个元素相等，则说明它是重复元素
//   5. 因为重复元素有可能是重复多次的，因此此时又要计算该重复元素重复了几次
//   6. 即 从当元素的 之后的第二个元素开始遍历（之后的第一个已经是相等的就不用判断了），判断是与当前元素相等
//   7. 如果相等则计数器+1，否则停止遍历
//   8. 当知道重复了几次之后，假如是3次，则从当前元素之后的3个元素都往前移动3格，
//   9. 例如 [2,2,2,2,4,5,6,6,6] 元素2重复了3次，当前元素时第一个2，他之后的第三个元素 最后一个2，即从最后一个2开始，每个元素往前移动3格
//  10. 假如当前元素已经是最大值，则说明去重已经结束，用当前索引 +1 则为去重后数组的长度
//  11. [2,2,2,2,4,5,6,6,6] 去重后，就变成 [2,4,5,6,-,-,-,-,-] 按照当前解题思路，【-】会都是6，而当前元素5之后的那个6，此时结束循环


/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function (nums) {
  const length = nums.length;
  let maxValue = nums[length - 1]; // 记录最大元素

  for (let i = 0; i < length - 1; i++) {
    // 当访问到最大值元素时，表明重复元素已经全部剔除完毕
    if (nums[i] === maxValue) {
      return i + 1;
    }

    if (nums[i] !== nums[i + 1]) {
      continue;
    }

    // 统计当前元素重复的次数
    let count = 1;

    // 计算当前元素重复的个数  i+1 已经是相等的了 因此从 i+2 开始判断
    for (let j = i + 2; j < length; j++) {
      if (nums[i] !== nums[j]) {
        break;
      }

      count++;
    }

    // 数组往前移动
    for (let j = i; j < length; j++) {
      let moveIndex = j + count;

      // 判断是否越界 越界了则表明数组已经全部移动完成
      if (moveIndex >= length) {
        break;
      }

      nums[j] = nums[moveIndex];
    }
  }
};
